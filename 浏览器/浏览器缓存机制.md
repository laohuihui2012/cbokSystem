缓存可以说是性能优化中简单高效的一种优化方式，合理的使用缓存可以缩短请求资源的距离，减少延迟。

由于缓存文件可以重复利用还能降低对宽带的要求

### 缓存分类
从缓存位置来看可以分为四种：
- Service Worker （是运行在浏览器背后的独立线程，使用 Service Worker的话，传输协议必须为 HTTPS。

它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。）

- Memory Cache
（内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等

内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了）

- Disk Cache
（存储在硬盘中的缓存，Memory Cache 胜在容量和存储时效性上。

并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据）

- Push Cache
（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用）

### 缓存过程分析
缓存的过程：
浏览器第一次发起http请求，会去查看有没有缓存和缓存表示 =》没有发送请求 =》返回请求结果和缓存规则 =》将请求结果和缓存标识存进缓存中

详情请看：images中浏览器缓存图片

### 缓存机制
#### 强缓存
强缓存不会发起HTTP请求，直接从缓存中读取资源

(在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache)

强缓存的实现通过设置HTTP header中的 Expires 和 Cache-Control 实现

##### 1.Expires
HTTP 1.0的产物

Expires=max-age + 请求时间  缓存到期时间，用来指定缓存资源的到期时间。需要配合last-modified结合使用，通过判断时间是否过期来决定缓存是否可用。 这样就有一个缺点，浏览器端本地时间可能会造成缓存失败

##### 2.Cache-Control
HTTP/1.1 的产物

当 Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。
Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：


两者同时存在的话Cache-Control优先级高于Expires

### 协商缓存
强制缓存判断只是根据是否超过某个时间或某个时间段，并不关系服务器端文件的更新。想要知道文件是否更新就要说到了协商缓存了。

协商缓存就是 强制缓存失效后，浏览器发起请求携带缓存表示，由服务器根据缓存标识决定是否使用缓存的过程。

 - 协商缓存生效，返回304和Not Modified：
 - 协商缓存失效，返回200和请求结果
##### 1.Last-Modified和If-Modified-Since （HTTP 1.0）
简单的来说，就是第一次请求成功后给一个标记时间Last-Modified，然后再次请求携带If-Modified-Since（值就是Last-Modified的值），

对比If-Modified-Since和服务器中文件最后的修改时间，没有变化则表示资源无更新，返回304和空的响应体。

直接从缓存读取小于就文件已经更新，于是返回新的资源文件和200
```
浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，

浏览器接收后缓存文件和header；Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT

浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；

服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，

直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200
```

Last-Modified 存在一些弊端；
- 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源

- 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源

- 现在大多数服务端都采用了负载均衡策略,可能导致不同虚拟主机返回的Last-Modified时间戳不一致,导致对比失败

##### 2.ETag和If-None-Match （HTTP 1.1）
Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化就会重新生成Etag.

然后浏览器在下一次请求时，会将Etag的值放入request header的If-None-Match里。服务端比较If-None-Match和服务端的Etag值就知道资源有无变化

两者对比:
- Etag在精度上优于Last-Modified，上面说过了Last-Modified是以秒为单位的。
- Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。
- 服务器校验优先考虑Etag

#### 了解了这些之后，我们终于可以总结一下缓存机制了

- 强缓存优先于协商缓存，若强缓存生效，直接读取缓存里面的资源不发请求。

- 若强缓存失效，则进行协商缓存，协商缓存时由服务器决定是否缓存，若缓存失效，返回状态值200，重新返回资源和缓存标识，再存入浏览器缓存中。若生效则直接返回304，继续使用缓存

如果什么缓存策略都没设置，那么浏览器会怎么处理？

 对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。

#### 实际场景应用缓存策略

1.对于频繁变动的资源，首先需要使用 Cache-Control:no-cache 使浏览器每次都请求服务器，

然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小

2.不常变化的资源

通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age=31536000 (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。在线提供的类库 (如 jquery-3.3.1.min.js, lodash.min.js 等) 均采用这个模式。

 