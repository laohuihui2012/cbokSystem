### 1.回收机制
JS有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理。

常用的两种垃圾回收规则是：

- 标记清除
- 引用计数

##### 1)标记清除 （js高级3）
Javascript引擎基础GC方案是（simple GC）：mark and sweep（标记清除），简单解释如下：

- 遍历所有可访问的对象。
- 回收已不可访问的对象。

当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。
从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。

而当变量离开环境时，则将其标记为“离开环境”。

垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。

然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记）。

而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。

最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。
##### 2)引用计数
跟踪记录每个值被引用的次数。当声明一个变量并将一个引用类型值赋给该变量时，这个值的引用次数为1。

如果同一个值又被赋给另一个变量，则该值的引用次数加1.相反，如果包含对这个值引用的变量又取得另一个值，该值得引用次数减1。

当这个值得引用次数为0时，则表示没有办法访问这个值了。这个时候就会将其占用得空间回收（容易出循环引用的bug）


### 2.内存泄漏的原因
虽然js有垃圾回收机制，但我们在编写代码的时候，有些情况还是会造成内存泄漏，了解这些情况，并在编写程序的时候，注意避免，我们的程序会更加完善。

1.上文我们提到了全局变量不会被当成垃圾回收，我们在编码中有时会出现下面这种情况：
```
 function foo() {
     this.bar2 = '默认绑定this指向全局' // 全局变量=> window.bar2
      bar = '全局变量'; // 没有声明变量 实际上是全局变量=>window.bar
   }
 foo();
```
 *1.当我们使用默认绑定，this会指向全局，this.something也会创建一个全局变量，这一点可能很多人没有注意到。

解决方法：在函数内使用严格模式or细心一点
```
function foo() {
    "use strict"; 
    this.bar2 = "严格模式下this指向undefined"; 
    bar = "报错";
}
foo();
```
 * 2.当不需要setInterval或者setTimeout时，定时器没有被clear，定时器的回调函数以及内部依赖的变量都不能被回收，造成内存泄漏。
```
var someResource = getData();
setInterval(function() {
    var node = document.getElementById('Node');
    if(node) {
        node.innerHTML = JSON.stringify(someResource));
        // 定时器也没有清除
    }
    // node、someResource 存储了大量数据 无法回收
}, 1000);
```
解决方法： 在定时器完成工作的时候，手动清除定时器。

* 3.循环引用问题，上文有提到

* 4.没有清理DOM元素引用：
html:
```
<div id="test">
    <span>1</span>
    <span>2</span>
  </div>

var refA = document.getElementById("test");
document.body.removeChild(refA); // dom删除了
console.log(refA, "refA");  // 但是还存在引用 能console出整个div 没有被回收
refA = null;//解决方法
console.log(refA, "refA");  // 解除引用
```
* 5.console保存大量数据在内存中。过多的console，比如定时器的console会导致浏览器卡死。

* 如何避免内存泄漏
 -1.减少不必要的全局变量，使用严格模式避免意外创建全局变量。
 -2.在你使用完数据后，及时解除引用(闭包中的变量，dom引用，定时器清除)。
 -3.组织好你的逻辑，避免死循环等造成浏览器卡顿，崩溃的问题。
