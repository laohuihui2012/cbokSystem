# 浏览器的主要工作流
我们从`url输入到页面渲染完成`来梳理一下浏览器工作的相关流程...

### 浏览器主要进程
- 浏览器进程主要负责用户交互、子进程管理和文件储存等功能。

- 网络进程是面向渲染进程和浏览器进程等提供网络下载功能。

- 渲染进程的主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面

 三个进程之间会有一些协作
 ```
浏览器进程: 用户输入url → 处理输入↓  (如果30x则会重定向) ↓ ... 接受网络进程的数据,发送给渲染进程(commit navigation) -> 收到确认信息, 导航结束,让渲染进程开始干活 -> 解析完毕生成展示页面

网络进程:   DNS(先在缓存查找)解析出ip → 发起http/https请求(3次/tsl握手,建立tcp连接) → 读取响应数据并发送 ↑ -> 断开连接

渲染进程:   通过管道接受网络进程的html数据 → 向浏览器进程发送确认信息 -> 开始解析html
```
### 主要流程总结

- 1.DNS解析

- 2.TCP连接

- 3.发送HTTP请求

- 4.服务器处理请求并返回HTTP报文

- 5.浏览器解析渲染页面

- 8.连接结束


#### DNS解析
DNS解析的过程就是寻找哪台机器上有你需要资源的过程
```
当你在浏览器中输入一个地址时，例如www.baidu.com，其实不是百度网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析。它实际上充当了一个翻译的角色，实现了网址到IP地址的转换。

```
首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，

本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。

从上述过程中，可以看出网址的解析是一个从右向左的过程: com -> google.com -> www.google.com。真正的网址是www.google.com.，这个.对应的就

是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网

址真正的解析过程为: . -> .com -> google.com. -> www.google.com.。

#### DNS负载均衡
```
其实真实的互联网世界背后存在成千上百台服务器，为一个网站提供请求服务。DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。大家耳熟能详的CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容
```

#### HTTP请求
其实这部分又可以称为前端工程师眼中的HTTP，它主要发生在客户端。发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文。

请求行
格式如下:
Method Request-URL HTTP-Version CRLF

eg: GET index.html HTTP/1.1
常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。

#### 服务器处理请求并返回HTTP报文
自然而然这部分对应的就是后端工程师眼中的HTTP。后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，

HTTP响应报文也是由三部分组成: 状态码, 响应报头和响应报文。

状态码
状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:

1xx：指示信息–表示请求已接收，继续处理。

2xx：成功–表示请求已被成功接收、理解、接受。

3xx：重定向–要完成请求必须进行更进一步的操作。

4xx：客户端错误–请求有语法错误或请求无法实现。

5xx：服务器端错误–服务器未能实现合法的请求。

## 渲染进程工作流
- 1.DOM Tree 构建
```
当渲染进程接收到导航的确认信息,开始接受HTML数据时,主线程会解析文本字符串为 DOM;
这里依靠 HTMl 解析器: 
接受字节流 -> 维护 token 栈 -> 生成节点node -> 组成 DOM;

遇到内嵌 script 时, DOM解析工作停止; js引擎介入执行(可能会修改dom结构);
执行完 js 后恢复解析工作, 所以 js 会阻塞 dom 解析.

遇到其他内联资源时(css,img)会通知网络进程去下载, 特别是 css;
js 在操作dom 样式时会依赖cssom,生成 layoutTree也需要 cssom; 
所以 css 又会阻塞 js 的执行
```
- 2.样式计算, 构建cssom(css规则树)
```
这里会基于 CSS 选择器解析 CSS 获取每一个节点的最终的计算样式值;
对应的就是styleSheets
```
- 3.计算布局, 生成layout tree
```
想要渲染一个完整的页面,除了获知每个节点的具体样式,还需要获知每一个节点在页面上的位置,
布局其实是找到所有元素的几何关系的过程。

这里通过遍历 DOM 及相关元素的计算样式,主线程会构建出包含每个元素的坐标信息及盒子大小的布局树。
布局树和 DOM 树类似,但是其中只包含页面可见的元素,如果一个元素设置了 `display:none` ,
这个元素不会出现在布局树上,伪元素虽然在 DOM 树上不可见,但是在布局树上是可见的。
```
- 4.分层,绘制(layer -> paint)
```
为特定的节点生成专用图层(will-change属性), 生成 图层树;
为图层生成绘制表(记录了绘制指令和顺序), 提交到合成线程
```
- 5.分块,光栅化
```
合成线程将图层分为图块, 通过光栅化生成位图(GPU 进程)
```
- 6.合成,显示
```
图块被光栅化后会生成一个绘制命令, 通过 IPC 提交给浏览器进程去执行,
绘制到内存中然后展示在显示器上
```



### CSS 与 JS 是这样阻塞 DOM 解析和渲染的

通过<script>与<link>引入外部资源，当解析到该标签的时候，会进行下载。
```
- 1.CSS脚本的加载不会阻塞 DOM 解析过程，但是会阻塞渲染过程(painting)

- 2.JS脚本的加载与执行会阻塞 DOM 解析过程, 但是不会阻塞后续资源的加载

- 3.JS脚本的加载中，如果你确定没必要阻塞 DOM 解析的话，不妨按需要加上 defer 或者 async 属性，此时脚本下载的过程中是不会阻塞 DOM 解析的。

- 4.浏览器遇到 <script>且没有 defer 或 async 属性的标签时，为了为<script>标签内部的js提供最新的信息，会触发页面的回流、重绘过程。

- 5.如果前面 CSS 资源尚未加载完毕时，浏览器会等待它加载完毕之后再执行脚本。即 css 不阻塞 js 的加载，但阻塞它的执行。
```
所以<script>最好放底部(防止阻塞DOM解析)。<link>最好放头部(为渲染过程提供样式)。如果头部同时有<script>与<link>的情况下，最好将<script>放在<link>上面(为了防止CSS脚本加载时间过长，使js等待时间也很长)