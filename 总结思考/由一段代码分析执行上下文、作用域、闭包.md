我们现在先来看一段代码
```
var a = { n: 1 };
var b = a;
a.x = a = { n: 2 }
console.log(a.x);
console.log(b);
```
在以前，我只能简单的以为就是创建变量、赋值、改变值。其实里面有很多步骤的，接下来我们就一一分析

#### 1.知识点

在分析代码运行之前，我们得先知道几个知识点

浏览器能够运行JS代码：是因为它会在计算机的内存中分配出一块内存，用来供代码执行的

- =>栈内存 Stack  ECStack =>执行环境栈
------
var[变量] = [值];
 第一步：先是创建值（默认是从右到左执行，如果有优先级高得先执行优先级最高的）
    + 基本类型值：直接存储在栈内存中
    + 引用类型值：在堆内存(Heap)中开辟单独的内存空间，用来存储信息

第二步:声明变量 declare
    +存放到当前上下文的变量对象中(VO/AO)

第三步：让变量和值关联到一起，也就是赋值操作(defind)
    所以var n;默认值是undefind
-------

```
- 首先浏览器解析代码的时候，先在栈内存创建一个全局执行环境栈（ECStack）  
  栈内存=>供代码执行 & 存储基本数据类型

- 然后为了区分在那个区域下的代码执行，会创建一个全局上下文EC(G),里面包含VO(G)全局变量对象，里面保存着变量名和引用地址，遇到变量赋值基本类型值，将变量和值关联起来，
引用类型的将变量和引用地址关联起来

- 当然还存在一个进栈的过程，然后再执行代码
  注意：引用类型的值改变，是改变变量的引用地址
```
所以这段代码执行过程就出来了，但是要注意的是，a.x = a = { n: 2 }的执行过程。

这里是先执行开辟一个内存储存{ n:2 }，然后将{ n:2 }的引用地址赋值给a.x,然后再将{ n:2 }的引用地址赋值给a。

所以a.x是undefind,b是{n:1,x:{n:2}}   =>因为成员访问的优先级(19)高，仅次于()运算的优先级

#### 包含函数代码执行过程
上面只有全局上下文代码，接下来看有函数代码的执行过程
```
var x = [12,23];
 function fn(y) {
     y[0] = 100;
     y = [100];
     y[1] = 200;
     console.log(y);
}

fn(x);
console.log(x);
```
再分析这段代码执行之前，我们也得先了解几个知识点

1.JS中的上下文有：
 + 全局上下文 EC(G)
 + 函数执行形成私有上下文
 + 块级私有上下文

2.创建一个函数和创建一个变量时类似的：
  + 都时声明一个变量存储值
  比如：function fn(y){....} 类型于 var fn = function(y){.....},相当于把一个函数赋值给一个变量
  + 创建函数也需要开辟一个堆内存存储（代码字符串）
  + 创建函数的时候就声明了它的作用域（scope:值就是当前创建函数时候所处的上下文）
  + 创建函数内私有变量和形参变量存储在函数上下文的【私有变量对象】AO中

3.函数执行的步骤：
  - 1.形成一个私有的上下文（其中有AO私有变量对象，存储当前上下文声明的变量对象），然后进栈执行
  - 2.代码执行前：
    + 初始化作用域链：scope-chain
    + 初始化this
    + 初始化arguments
    + 形参赋值：在当前上下文中声明一个形参变量，并且把传递的实参赋值给它
    + 变量提升
  - 3.代码执行
  - 4.出栈释放

##### 作用域查找机制
私有上下文中代码执行，如果遇到一个变量，首先看是否为自己的"私有变量"，如果有私有的，则操作自己私有的变量，

和外层的没有必然关系；如果没有则基于作用域链向上级上下文查找，看上级上下文中私有的变量有吗，

如果没有则继续向上查找....。一直找到全局上下文EC(G)为止，这种查找过程就是作用域链的查找机制

##### GC:浏览器的垃圾回收机制(内存释放机制)
```
- 【栈内存释放】
   + 加载页面，形成一个全局上下文，只有在页面关闭之后，全局上下文才会被释放
   + 函数执行会形成一个私有的上下文，进栈执行;当函数中代码执行完成，大部分情况下，形成的上下文都会被出栈释放掉，以此优化栈内存大小
- 【堆内存释放】
   方案一：查找引用（谷歌）
        浏览器在空闲或者指定阿时间内，查看所有的堆内存，把没有被任何东西占用的堆内存释放掉，占用的不被释放
   方案二:引用计算
        创建了堆内存，被占用一次，则浏览器计算+1，取消占用一次则计算-1.当计算为0的时候，则内存被释放掉。
        但是某些情况下计算混乱则会出现"内存泄漏" =>循环引用

```
    
