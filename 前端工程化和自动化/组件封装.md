### 模块化，组件化
刚开始提到模块化、组件化，感觉就像大家都在喊的口号，这东西只有自己去实践了才会有容易理解；

- 模块化主要是以功能和业务逻辑模块划分的，一个砍价功能作为一个模块，或者是订单模块。
对模块化最具体的体现在我们的项目文件目录结构上，比如砍价模块，我会建一个文件夹专门存放砍价这块的主要代码，
例如砍价需要特定的弹窗组件，砍价通用列表等

- 组件化主要是以ui视图和逻辑代码划分

 ### 组件设计思路
#### 单一责任原则
软件工程评论设计好坏的第一个想到的当然是高内聚低耦合，所谓高内聚是指一个软件模块是由相关性很强的代码组成，只负责一项任务，也就是常说的单一责任原则。

实例说明：
```
比如订单模块，订单是跟库存息息相关的，没有库存就没有订单，订单强依赖库存。

把扣减库存的逻辑直接写在在订单模块中，那么订单模块和库存模块就耦合了另一方面，订单模块中有扣减库存的逻辑会造成订单模块的功能比较分散，
功能就不够集中，便构成了低内聚。

把订单中的库存逻辑给拆分出来一个独立的库存模块，库存模块对外暴露扣减库存的接口，订单模块调用接口实现减少库存的操作，
将订单逻辑与库存逻辑的依赖降低到最小，减小了订单与库存的耦合。

同时订单模块只包含订单处理的逻辑，库存系统只包含库存的处理逻辑，两个系统的业务上更加内聚
```
 #### 复用性强
 我们封装组件的目的就是为了：代码已于维护和代码复用性
 
在我们刚开时准备设计一个组件时，我们要去看看其他地方有能用到吗，有的话考虑他的复用概率和抽取的维护的难度，不能为了两个三个地方用到，去抽取一个很很复杂的组件

#### 组件粒度的考虑

在我们抽取组件时，不能为了抽取而抽取。在抽取前我们要问自己，为什么要抽取，是为了复用，还是为了代码更加清晰明了。组件粒度要合适



#### 其实组件的封装设计没有什么规定死标准，需要跟据不能项目选择更优的处理，而且还随需求的改变组件需要重新修改设计。

 - 这个组件可否（有必要）再分？
组件划分的依据通常是 业务逻辑、功能，要考虑各组件之间的关系是否明确（如组件树方式管理组件间依赖关系，兄弟组件不可见），以及组件的可复用度。

划分粒度的大小需要根据实际情况权衡，太小会提升维护成本，太大又不够灵活和高复用性。

每一个组件都应该有其独特的划分目的的，有的是为了复用实现，有的是为了封装复杂度清晰业务实现。



 - 这个组件的依赖是否可再缩减？
缩减组件依赖可以提高组件的可复用度，常用的方法是IoC（依赖注入），对外弱类型依赖。



 - 这个组件是否对其它组件造成侵入？
一个组件的封装性不够，或者自身越界操作，就可能对自身之外造成了侵入，这种情况应该尽量避免，确保组件的生命周期能够对其影响进行有效的管理（如destroy后不留痕迹）。

较常见的一种情况是：组件运行时对window对象添加resize监听事件以实现组件响应视窗尺寸变化事件，这种需求的更好替代方案是：组件提供刷新方法，由父组件实现调用（最终由根组件统一处理）。

次优的方案是，当组件destroy前清理恢复。

一个组件不应对其它兄弟组件造成直接影响。



- 这个组件可否复用于其它类似场景中？
需要考虑需要适用的不同场景，在组件接口设计时进行必要的兼容。



这个组件当别人用时，会怎么想？
接口设计符合规范和大众习惯，尽量让别人用起来简单易上手，易上手是指更符合直觉。



假如业务需要不需要这个功能，是否方便清除？
各组件之前以组合的关系互相配合，也是对功能需求的模块化抽象，当需求变化时可以将实现以模块粒度进行调整。  
