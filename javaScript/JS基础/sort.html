<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    // let arr = [4, 10, 40, 38, 56, 39, 36, 9];


    // function fastSort(arr) {
    //     let len = arr.length,
    //         preIndex,
    //         current

    //     for (let i = 1; i < arr.length; i++) {
    //        preIndex = i - 1;
    //        current = arr[i];
    //        while(preIndex >= 0 && current < arr[preIndex]){
    //            arr[preIndex + 1] = arr[preIndex];
    //            preIndex--;
    //        }
    //        arr[preIndex + 1] = current;
    //     }
    //     return arr;
    // }

    // console.log(fastSort(arr))
    import Dep from './Dep.js'
    import arrayMethods from './arrayMethods.js'
    import defineReactive  from './defineReactive.js'
    import observe from './observe.js';
    export default class Observer {
        constructor(value) {
            this.dep = new Dep() // // 每一个Observer的实例身上，都有一个dep
            def(value, '__ob__', this, value ); // (this，构造函数中的this不是表示类本身，而是表示实例)
            // 判断是数组还是对象
            if(Array.isArray(value)) { 
                // 将这个数组的原型，指向arrayMethods
                Object.setPrototypeOf(value, arrayMethods);

                this.observeArray(value);
            } else {
                this.walk(vale);
            }
        }
        // 对象遍历
        walk(value) {
            for (const key in value) {
                defineReactive(value, key);
            }
        }

        // 数组遍历特殊处理
        observeArray(arr) {
            for (let i = 0; index < arr.length; i++) {
                observe(arr[i]) // 逐项进行observe
            }
        }
    }

    function def(obj, key, value, enumerable) {
        Object.defineProperty(obj, key, {
            value,
            enumerable, // 不能枚举
            writable: true,
            configurable: true,
        })
    }

    import { def } from './utils.js';

    // 先保存好Array.prototype
    const arrayPrototype = Array.prototype;
    // 以Array.prototype 为原型，创建arrayMethods对象
    const arrayMethods = Object.create(arrayPrototype)
    // 改写7个方法
    const methodsNeedChange = [
        'push',
        'pop',
        'shift',
        'unshift',
        'splice',
        'reverse',
        'sort'
    ]

    methodsNeedChange.forEach( methodName => {
        // 先备份好原来得方法,这些方法原有的功能不能丢失
        const originMthod = arrayPrototype[methodName];
        // 定义新的方法
        def(arrayMethods, methodName, function(params) {
            // 恢复原来的功能
            const result = originMthod.call(this, arguments);
            // 把类数组变成数组
            const args = [...arguments];
            ob = this.__ob__ // 此时一定是存在__ob__的，因为数组肯定不是最高层，
            // 比如obj.g属性是数组，obj不能是数组，第一次遍历obj这个对象的第一层的时候，已经给g属性（就是这个数组）添加了__ob__属性。
            
            // 有三项是能又插入新项的，把插入的新项也observe
            let inserted = [];
            switch (methodName) {
                case 'push':
                case 'unshift':
                    inserted = args;
                    break;
                case 'splice':
                    inserted = args.slice(2); // splice格式是splice(下标, 数量, 插入的新项)
                default:
                    break;
            }

            // 判断有没有新项目被加入，有也变成响应式的
            if(inserted) {
                ob.observeArray(inserted); // ob就是保存的value.__ob__,也就是Observer实例
            }

            ob.dep.notify();

            return result;
        }, false)
    })

    import Dep from './Dep.js';

    var uid = 0;
    export default class Watcher {
        constructor(target, expression, callback) {
            this.id = uid++;
            this.target = target;
            this.getter = parsePath(expression); // 解析表达式的（obj.a.b)
            this.value = this.get()
        }

        updated() {
            this.run()
        }

        get() {
            // 让全局的Dep.target设置为Watcher实例本身，就进入了依赖收集阶段
            Dep.target = this;
            const obj = target;
            var value;

            try {
                // 只要能找就一直往下找
                value = this.getter(obj);
            } finally {
                // 结束时需要释放Dep.target位置
                Department.target = null;
            }

            return value;
        }

        run() {
            this.getAndInvoke(this.callback);
        }

        getAndInvoke(cb) {
            var value = this.get(); // 获取当前值
            
            if(value !== this.value || typeof value === 'object' ) {
                const oldValue = this.value; // 保存老的值
                this.value = value; 
                cb.call(this.target, value, oldValue)
            }

        }
    }

    function parsePath(expr) {
        var exprArr =  expr.split('.');

        return (obj) => {
            for (let i= 0; i < exprArr.length; i++) {
                if(!obj) return;
                obj = obj[exprArr[i]];
            }
            return obj
        }
    }
    
</script>

</html>