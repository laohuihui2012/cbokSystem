<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    // let arr = [4, 10, 40, 38, 56, 39, 36, 9];


    // function fastSort(arr) {
    //     let len = arr.length,
    //         preIndex,
    //         current

    //     for (let i = 1; i < arr.length; i++) {
    //        preIndex = i - 1;
    //        current = arr[i];
    //        while(preIndex >= 0 && current < arr[preIndex]){
    //            arr[preIndex + 1] = arr[preIndex];
    //            preIndex--;
    //        }
    //        arr[preIndex + 1] = current;
    //     }
    //     return arr;
    // }
    import vnode from './vnode.js'
    import createElement from './createElement.js'
    import patchVnode from './patchVnode.js'
    // 传入新老节点
    export default function patch(oldVnode, newVnode) {
        //判断传入的第一个参数是否是虚拟节点，
        if(oldVnode.sel === '' || oldVnode.sel === undefined) {
            // 包装成虚拟节点
            oldVnode = vnode(oldVnode.tagName.toLowerCase(), {}, [], undefined, oldVnode);
        }
        
        // 判断oldVnode和newVnode是否是同一节点
        if(oldVnode.key === newVnode.key && oldVnode.sel === newVnode.key) {
            // 同一节点
            patchVnode(oldVnode, newVnode);
        } else {
            // 不是同一节点就创建插入新节点，删除老节点
            let newVnodeElm = createElement(newVnode);
            // 插入到老节点之前
            if(newVnodeElm && oldVnode.elm.parentNode) {
                oldVnode.elm.parentNode.insertBefore(newVnodeElm, oldVnode.elm);
            }

            // 删除老节点
            oldVnode.elm.parentNode.removeChild(oldVnode.elm);
        }
    }
    
    // 真正创建节点。将vnode创建为DOM
    export default function createElement(vnode) {
        let domNode = document.createElement(vnode.sel)  // 创建一个节点，此时节点还没上树（孤儿节点）
        // 判断该节点有子节点是有文本
        if(vnode.text !== '' && (vnode.children === undefined || vnode.children.length === 0)) {
            // 内部是文本
            domNode.innerText = vnode.text;
        } else if( Array.isArray(vnode.children) && vnode.children.length > 0 ) {
            for(let i = 0; i < vnode.children.length; i++) {
                let ch = vnode.children[i];
                // 创建出子节点的DOM，此时也是还没上树
                let chdomNode = createElement(ch);
                // 上树
                domNode.appendChild(chdomNode)
            }
        }
        // 补充elm属性
        vnode.elm = domNode;
        // 返回elm，elm属性是一个纯DOM对象
        return vnode.elm;
    }

    import createElement from "./createElement";
    import updateChildren from './updateChildren.js';
    export default function patchVnode(oldVnode, newVnode) {
        // 判断是否时同一个对象
        if(oldVnode === newVnode) return; // 同一对象不处理
        // 判断新节点有没有text属性
        if(newVnode.text !== undefined && (newVnode.children === undefined || newVnode.children.length === 0)) {
            // 老节点也有text属性
            if(newVnode.text !== oldVnode.text) {
                // 新旧节点的text不同，直接让新节点的text写入老的elm中，如果老节点是有children节点，也会被清掉
               oldVnode.elm.innerText = newVnode.text; 
            } 
        } else {
            // 新节点有children属性
            if(oldVnode.children.length > 0 && oldVnode.children !== undefined) {
                // 老节点有children属性
                // 调用updateChildren，对新老节点的children进行更优雅的比较
                updateChildren(oldVnode.elm, oldVnode.children, newVnode.children);
            } else {
                // 老节点有text属性
                oldVnode.elm.innerHTML = ''; // 清空老节点上的文本内容
                // 遍历新节点的，创建子节点的DOM，上树
            }
        }
    }
</script>

</html>