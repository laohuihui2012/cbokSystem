## 原型链
刚开始学习原型链的时候，脑袋里面真的很混乱（什么原型对象呀，什么prototype属性呀 __proto__属性呀），因为这些东西很抽象，而且刚开始学习我也不知道它是用来干啥的

其实学一个东西你要了解他的背景和它的作用之后，你就会很容易理解为什么会有这个东西，为什么是这么设计的

JS 中的数据类型设计受当时 Java流行的影响，都是对象类型，有对象必然涉及到继承机制，但是JS又没有类的概念，得设计一套自己的继承机制。于是就有了原型对象作为存放公共方法和属性，通过原型继承属性和方法

在我们使用构造函数创建类或对象时，会为每个实例化对象或者函数创建一些私有属性和方法，但是有一些一样的方法，我们不可能每次创建实例多创建一个，这样浪费内存也完全没必要。于是设计一个对象专门用来存储对象共享的属性，叫做原型对象
然后又给构造函数加了一个prototype属性，指向原型对象
给实例对象一个__proto__属性指向原型对象
给原型对象一个constructor属性指向自己的构造函数

这样一下就明白了构造函数和原型对象和实例化三者的关系了，以及prototype属性、__proto__、constructor的由来和作用了（详细请看images文件中的原型图）

总结：
1、所有的实例的_proto_都指向该构造函数的原型对象（prototype）。

2、所有的函数（包括构造函数）是Function的实例，所以所有函数的_proto_的都指向Function的原型对象。

3、所有的原型对象（包括 Function的原型对象）都是Object的实例，所以_proto_都指向 Object（构造函数）的原型对象。而Object构造函数的 _proto_指向 null。

4、Function构造函数本身就是Function的实例，所以_proto_指向Function的原型对象。

https://blog.csdn.net/qq_36903042/article/details/102715465

##### 接下来我们就可以讲原型链了
每个实例对象都有一个__proto__属性指向原型对象，原型对象的也有原型对象（同时也有一个__proto__属性指向自己的原型对象），直到向上找到了null，这就构成了一条原型链

function Dog(name,weight){
    this.name = name;
    this.weight = weight;
    this.type = '犬类'
}

var dog1 = new Dog('哈哈',250);
var dog2 = new Dog('嘻嘻',180);
console.log(dog1.type === dog2.type) 

## 继承
使用原型链实现继承注意点：
1.不能使用字面量定义原型方法，因为这样会重写原型对象
---
  function SuperClass(){
    this.name = "women"
  }
  SuperClass.prototype.sayWhat = function(){
    return this.name + ":i`m a girl!";
  }
  function SubClass(){
    this.subname = "your sister";
  }
  SubClass.prototype = new SuperClass();
  SubClass.prototype = {//此处原型对象被覆盖，因为无法继承SuperClass属性和方法
    subSayWhat:function(){
      return this.subname + ":i`m a beautiful girl";
    }
  }
  var sub = new SubClass();
  console.log(sub.sayWhat());//TypeError: undefined is not a function
---
2.继承而来的原型中也会共享“父类”原型中引用类型的属性，当我们通过原型继承修改了“父类”的引用类型属性后，其他所有继承自该原型的实例都会受到影响

这样说可能很很难看懂，我们看下面的例子吧，SubClass继承了SuperClass实例的引用类型数据，当我们修改 sub1继承来的这个属性时，SuperClass构造函数的其他实例化的数据也会受到影响
---
  function SuperClass(){
    this.name = "women";
    this.bra = ["a","b"];
  }
  function SubClass(){
    this.subname = "your sister";
  }
  SubClass.prototype = new SuperClass();
  var sub1 = new SubClass();
  sub1.name = "man";
  sub1.bra.push("c");
  console.log(sub1.name);//man
  console.log(sub1.bra);//["a","b","c"]
  var sub2 = new SubClass();
  console.log(sub1.name);//woman
  console.log(sub2.bra);//["a","b","c"]
---
