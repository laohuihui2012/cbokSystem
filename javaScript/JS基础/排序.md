#### 冒泡排序
依次比较相邻的两个值，如果后面的比前面的小，则将小的元素排到前面。依照这个规则进行多次并且递减的迭代，直到顺序正确。

每次比较相邻两个相邻“气泡”的"轻重’，“气泡”较重的往下"沉"，轻的往上”浮“。
详情请看images里面：冒泡排序图
```
 let arr = [4, 10, 40, 38, 56, 39, 36, 9];

function sort(arr) {
        let num = null;
        for (var i = 0; i < arr.length - 1; i++) {
            for (var j = 0; j < arr.length - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    num = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = num;
                }
            }
        }
        return arr
    }

console.log(sort(arr))
```
解析:
```
两个循环
当i=0的时候，里面的循环完整执行，从j=0执行到j=6,这也就是第一遍排序，结果是将最大的数排到了最后，
这一遍循环结束后的结果应该是[8,15,88,55,76,21,39,94]

当i=1的时候，里面的循环再次完整执行，由于最大的数已经在最后了，没有必要去比较数组的最后两项，
这也是j<arr.length-1-i的巧妙之处，结果是[8,15,55,76,21,39,88,94]

说到这里，规律就清楚了，每次将剩下数组里面最大的一个数排到最后面，当第一个循环执行到最后的时候，
也就是i=6,此时，j=0,只需要比较数组的第一和第二项，比较完毕，返回。
```
#### 选择排序

该方法会改变原来的数组，而不会创建新的数组。

原理： 首先从原始数组中找到最小的元素，并把该元素放在数组的最前面，
然后再从剩下的元素中寻找最小的元素，放在之前最小元素的后面，知道排序完毕。
```
let arr = [4, 10, 40, 38, 56, 39, 36, 9];

function sort(arr) {
    let num = null,
        minIndex
    for (var i = 0; i < arr.length - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j < arr.length; j++) {
            if(arr[j] < arr[minIndex]){
                minIndex = j;
            }
        }
        num = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = num
    }
    return arr
}

console.log(sort(arr))
//minIndex始终保存着最小值的位置的索引，随着i的自增，遍历的数组长度越来越短，直到完成排序。
```

#### 快速排序
原理：从数组中选定一个基数，然后把数组中的每一项与此基数做比较，小的放入一个新数组，
大的放入另外一个新数组。然后再采用这样的方法操作新数组。直到所有子集只剩下一个元素，排序完成。

```
let arr = [4, 10, 40, 38, 56, 39, 36, 9];


function fastSort(arr) {
    if(arr.length < 2) return arr;

    let left = [],
        right = [],
        pivotIndex = Math.floor(arr.length/2),
        pivot = arr.splice(pivotIndex,1)[0]

    for (let i = 0; i < arr.length; i++) {
        if(arr[i] < pivot){
            left.push(arr[i])
        }else{
            right.push(arr[i])
        }
    }
    return fastSort(left).concat([pivot],fastSort(right));
}

console.log(fastSort(arr))
```
#### sort()方法
arrayObject.sort(sortby)

如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。

要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较

如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。

比较函数应该具有两个参数 a 和 b，其返回值如下(这是升序，降序反过来)：

-若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。
-若 a 等于 b，则返回 0。
-若 a 大于 b，则返回一个大于 0 的值。
```
 let arr = [4, 10, 40, 38, 56, 39, 36, 9];

 function compare(a, b) {
        if(a < b){
            return -1;
        }else if(a > b){
            return 1;
        }else{
            return 0;
        }
    }
    arr.sort(compare);

    //也可以简化为
    function compare(a, b) {
         a - b;
    }
```
注意:数组在原数组上进行排序，不生成副本。



