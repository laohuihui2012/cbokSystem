### 内存空间
在说深浅拷贝之前，我们得先了解下内存空间和数据类型，以前因为不太了解对很多概率只能死记住，导致了很多错误得认识

在说内存空间之前，我们先了解三种数据结构：堆(heap)，栈(stack)与队列(queue)。

#### 栈数据结构
栈是一种 先进后出 得数据结构，以之前我们说过得执行上下文环境来说，
先进入执行栈的，在栈底，后进入执行栈的在栈顶，栈顶的执行上下文先执行弹出
具体图解可以看images里面的栈内存图片

#### 堆数据结构

堆数据结构是一种树状结构，它是无序存放的，类似于书架与书

书是无序的放在书架上的，我们通过书名可以找到书。好比在JSON格式的数据中，我们存储的key-value是可以无序的，因为顺序的不同并不影响我们的使用

#### 队列
队列是一种先进先出（FIFO）的数据结构。正如排队过安检一样，排在队伍前面的人一定是最先过检的人。

在JavaScript中，理解队列数据结构的目的主要是为了清晰的明白事件循环（Event Loop）的机制到底是怎么回事

#### 变量对象与基础数据类型
JavaScript的执行上下文生成之后，会创建一个叫做变量对象的特殊对象。JavaScript的基础数据类型往往都会保存在变量对象中。
基础数据类型都是一些简单的数据段：undefined，null,Boolean,Number,String

#### 引用数据类型与堆内存
JS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。

在JS中是不允许直接访问堆内存中的数据的，而是通过引用地址访问的。

在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。

```
var a1 = 0;   // 变量对象
var a2 = 'this is string'; // 变量对象
var a3 = null; // 变量对象

var b = { m: 20 }; // 变量b存在于变量对象中，{m: 20} 作为对象存在于堆内存中
var c = [1, 2, 3]; // 变量c存在于变量对象中，[1, 2, 3] 作为对象存在于堆内存中
```
详图请看images中的'堆内存'

当我们要访问堆内存中的引用数据类型时，实际上我们首先是从变量对象中获取了该对象的地址引用（或者地址指针），然后再从堆内存中取得我们需要的数据

#### 基本类型赋值和引用类型赋值
对于基本数据类型，如果进行复制，系统会自动为新的变量在栈内存中分配一个新值

对于引用类型，系统也会自动为新的变量在栈内存中分配一个值，但这个值仅仅是一个地址。也就是说，复制出来的变量和原有的变量具有相同的地址值，指向堆内存中的同一个对象。


#### 为什么基础数据类型存在栈中，而引用数据类型存在堆中呢？

1.栈比堆小，栈比对速度快。

2.基础数据类型比较稳定，而且相对来说占用的内存小。

3.引用数据类型大小是动态的，而且是无限的。 

4.堆内存是无序存储，可以根据引用直接获取。



### 深浅拷贝
了解了上面的知识后，我们就能很容易的理解深浅拷贝了。
深浅拷贝只是对于引用类型的数据而言

#### 浅拷贝
浅拷贝的意思就是只复制引用，而未复制真正的值。
如下面的例子：
```
const originArray = [1,2,3,4,5];
const originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};

const cloneArray = originArray;
const cloneObj = originObj;

cloneArray.push(6);
cloneObj.a = {aa:'aa'};

console.log(cloneArray); // [1,2,3,4,5,6]
console.log(originArray); // [1,2,3,4,5,6]

console.log(cloneObj); // {a:{aa:'aa'},b:'b',c:Array[3],d:{dd:'dd'}}
console.log(originObj); // {a:{aa:'aa'},b:'b',c:Array[3],d:{dd:'dd'}}
```

#### 深拷贝
 深拷贝是对目标的完全拷贝，堆内存中值要拷贝。
拷贝之后两个互相不影响

深拷贝的方法：
1.利用 JSON 对象中的 parse 和 stringify（undefined、function、symbol 会在转换过程中被忽略）
2.利用递归来实现每一层都重新创建对象并赋值
```
const originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};
const cloneObj = JSON.parse(JSON.stringify(originObj));
console.log(cloneObj === originObj); // false

cloneObj.a = 'aa';
cloneObj.c = [1,1,1];
cloneObj.d.dd = 'doubled';

console.log(cloneObj); // {a:'aa',b:'b',c:[1,1,1],d:{dd:'doubled'}};
console.log(originObj); // {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};
```
但是利用parse 和 stringify会出现属性丢失的请况，
```
const originObj = {
  name:'axuebin',
  sayHello:function(){
    console.log('Hello World');
  }
}
console.log(originObj); // {name: "axuebin", sayHello: ƒ}
const cloneObj = JSON.parse(JSON.stringify(originObj));
console.log(cloneObj); // {name: "axuebin"}
```
#### 利用递归
就是对每一层的数据都实现一次 创建对象->对象赋值 的操作：
```
function deepClone(source){
  const targetObj = source.constructor === Array ? [] : {}; // 判断复制的目标是数组还是对象

  for(let keys in source){ // 遍历目标
    if(source.hasOwnProperty(keys)){//判断source是否有key属性
      if(source[keys] && typeof source[keys] === 'object'){ // 如果值是对象，就递归一下
        targetObj[keys] = source[keys].constructor === Array ? [] : {};
        targetObj[keys] = deepClone(source[keys]);
      }else{ // 如果不是，就直接赋值
        targetObj[keys] = source[keys];
      }
    } 
  }

  return targetObj;
}
```

####  其他拷贝方法
数组有两个方法 concat 和 slice 是可以实现对原数组的拷贝的，这两个方法都不会修改原数组，而是返回一个修改后的新数组。

ES6 中 引入了 Object.assgn 方法和 ... 展开运算符也能实现对对象的拷贝。

但是，这四个方法只能深拷贝第一层，更深的层只是拷贝引用。我们可以叫这种为：首层深拷贝
```
const originArray = [1,[1,2,3],{a:1}];
const cloneArray = originArray.concat();
console.log(cloneArray === originArray); // false
cloneArray[1].push(4);
cloneArray[2].a = 2; 
console.log(originArray); // [1,[1,2,3,4],{a:2}]
```
实现首层深拷贝

```
function shallowClone(source) {
  const targetObj = source.constructor === Array ? [] : {}; // 判断复制的目标是数组还是对象
  for (let keys in source) { // 遍历目标
    if (source.hasOwnProperty(keys)) {
      targetObj[keys] = source[keys];
    }
  }
  return targetObj;
}
```
